

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta content="The lxml tutorial on XML processing with Python" name="description" />
<meta content="XML processing with Python, lxml, lxml.etree, tutorial, ElementTree, Python, XML, HTML" name="keywords" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The lxml.etree Tutorial &mdash; lxml 3.7.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/lxml_theme.css" type="text/css" />
  

  

  
        <link rel="author" title="About these documents"
              href="about.html"/>
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="lxml 3.7.2 documentation" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> lxml
          

          
          </a>

          
            
            
              <div class="version">
                3.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">The lxml.etree Tutorial</a><ul>
<li><a class="reference internal" href="#the-element-class">The Element class</a><ul>
<li><a class="reference internal" href="#elements-are-lists">Elements are lists</a></li>
<li><a class="reference internal" href="#elements-carry-attributes-as-a-dict">Elements carry attributes as a dict</a></li>
<li><a class="reference internal" href="#elements-contain-text">Elements contain text</a></li>
<li><a class="reference internal" href="#using-xpath-to-find-text">Using XPath to find text</a></li>
<li><a class="reference internal" href="#tree-iteration">Tree iteration</a></li>
<li><a class="reference internal" href="#serialisation">Serialisation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-elementtree-class">The ElementTree class</a></li>
<li><a class="reference internal" href="#parsing-from-strings-and-files">Parsing from strings and files</a><ul>
<li><a class="reference internal" href="#the-fromstring-function">The fromstring() function</a></li>
<li><a class="reference internal" href="#the-xml-function">The XML() function</a></li>
<li><a class="reference internal" href="#the-parse-function">The parse() function</a></li>
<li><a class="reference internal" href="#parser-objects">Parser objects</a></li>
<li><a class="reference internal" href="#incremental-parsing">Incremental parsing</a></li>
<li><a class="reference internal" href="#event-driven-parsing">Event-driven parsing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#namespaces">Namespaces</a></li>
<li><a class="reference internal" href="#the-e-factory">The E-factory</a></li>
<li><a class="reference internal" href="#elementpath">ElementPath</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">lxml</a>
        
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>The lxml.etree Tutorial</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/tutorial.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>

          <nav class="docs-nav">
            <a href="#">Tutorial</a>
            <a href="docindex.html">Docs</a>
            <a href="api_reference.html">API Reference</a>
            <a href="genindex.html">Index</a>
          </nav>

          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-lxml-etree-tutorial">
<h1><a class="toc-backref" href="#id2">The lxml.etree Tutorial</a><a class="headerlink" href="#the-lxml-etree-tutorial" title="Permalink to this headline">Â¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Stefan Behnel</td>
</tr>
</tbody>
</table>
<p>This is a tutorial on XML processing with <code class="docutils literal"><span class="pre">lxml.etree</span></code>.  It briefly
overviews the main concepts of the <a class="reference external" href="http://effbot.org/zone/element-index.htm#documentation">ElementTree API</a>, and some simple
enhancements that make your life as a programmer easier.</p>
<p>For a complete reference of the API, see the <a class="reference external" href="api/index.html">generated API
documentation</a>.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#the-lxml-etree-tutorial" id="id2">The lxml.etree Tutorial</a><ul>
<li><a class="reference internal" href="#the-element-class" id="id3">The Element class</a><ul>
<li><a class="reference internal" href="#elements-are-lists" id="id4">Elements are lists</a></li>
<li><a class="reference internal" href="#elements-carry-attributes-as-a-dict" id="id5">Elements carry attributes as a dict</a></li>
<li><a class="reference internal" href="#elements-contain-text" id="id6">Elements contain text</a></li>
<li><a class="reference internal" href="#using-xpath-to-find-text" id="id7">Using XPath to find text</a></li>
<li><a class="reference internal" href="#tree-iteration" id="id8">Tree iteration</a></li>
<li><a class="reference internal" href="#serialisation" id="id9">Serialisation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-elementtree-class" id="id10">The ElementTree class</a></li>
<li><a class="reference internal" href="#parsing-from-strings-and-files" id="id11">Parsing from strings and files</a><ul>
<li><a class="reference internal" href="#the-fromstring-function" id="id12">The fromstring() function</a></li>
<li><a class="reference internal" href="#the-xml-function" id="id13">The XML() function</a></li>
<li><a class="reference internal" href="#the-parse-function" id="id14">The parse() function</a></li>
<li><a class="reference internal" href="#parser-objects" id="id15">Parser objects</a></li>
<li><a class="reference internal" href="#incremental-parsing" id="id16">Incremental parsing</a></li>
<li><a class="reference internal" href="#event-driven-parsing" id="id17">Event-driven parsing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#namespaces" id="id18">Namespaces</a></li>
<li><a class="reference internal" href="#the-e-factory" id="id19">The E-factory</a></li>
<li><a class="reference internal" href="#elementpath" id="id20">ElementPath</a></li>
</ul>
</li>
</ul>
</div>
<p>A common way to import <code class="docutils literal"><span class="pre">lxml.etree</span></code> is as follows:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lxml</span> <span class="kn">import</span> <span class="n">etree</span>
</pre></div>
</div>
<p>If your code only uses the ElementTree API and does not rely on any
functionality that is specific to <code class="docutils literal"><span class="pre">lxml.etree</span></code>, you can also use (any part
of) the following import chain as a fall-back to the original ElementTree:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
  <span class="kn">from</span> <span class="nn">lxml</span> <span class="kn">import</span> <span class="n">etree</span>
  <span class="k">print</span><span class="p">(</span><span class="s2">&quot;running with lxml.etree&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="c1"># Python 2.5</span>
    <span class="kn">import</span> <span class="nn">xml.etree.cElementTree</span> <span class="kn">as</span> <span class="nn">etree</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;running with cElementTree on Python 2.5+&quot;</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="c1"># Python 2.5</span>
      <span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">as</span> <span class="nn">etree</span>
      <span class="k">print</span><span class="p">(</span><span class="s2">&quot;running with ElementTree on Python 2.5+&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="c1"># normal cElementTree install</span>
        <span class="kn">import</span> <span class="nn">cElementTree</span> <span class="kn">as</span> <span class="nn">etree</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;running with cElementTree&quot;</span><span class="p">)</span>
      <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
          <span class="c1"># normal ElementTree install</span>
          <span class="kn">import</span> <span class="nn">elementtree.ElementTree</span> <span class="kn">as</span> <span class="nn">etree</span>
          <span class="k">print</span><span class="p">(</span><span class="s2">&quot;running with ElementTree&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
          <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Failed to import ElementTree from any known place&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>To aid in writing portable code, this tutorial makes it clear in the examples
which part of the presented API is an extension of <code class="docutils literal"><span class="pre">lxml.etree</span></code> over the
original <a class="reference external" href="http://effbot.org/zone/element-index.htm#documentation">ElementTree API</a>, as defined by Fredrik Lundh&#8217;s <a class="reference external" href="http://effbot.org/zone/element-index.htm">ElementTree
library</a>.</p>
<div class="section" id="the-element-class">
<h2><a class="toc-backref" href="#id3">The Element class</a><a class="headerlink" href="#the-element-class" title="Permalink to this headline">Â¶</a></h2>
<p>An <code class="docutils literal"><span class="pre">Element</span></code> is the main container object for the ElementTree API.  Most of
the XML tree functionality is accessed through this class.  Elements are
easily created through the <code class="docutils literal"><span class="pre">Element</span></code> factory:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s2">&quot;root&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The XML tag name of elements is accessed through the <code class="docutils literal"><span class="pre">tag</span></code> property:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">root</span>
</pre></div>
</div>
<p>Elements are organised in an XML tree structure.  To create child elements and
add them to a parent element, you can use the <code class="docutils literal"><span class="pre">append()</span></code> method:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s2">&quot;child1&quot;</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>However, this is so common that there is a shorter and much more efficient way
to do this: the <code class="docutils literal"><span class="pre">SubElement</span></code> factory.  It accepts the same arguments as the
<code class="docutils literal"><span class="pre">Element</span></code> factory, but additionally requires the parent as first argument:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">child2</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;child2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">child3</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;child3&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>To see that this is really XML, you can serialise the tree you have created:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">&lt;root&gt;</span>
<span class="go">  &lt;child1/&gt;</span>
<span class="go">  &lt;child2/&gt;</span>
<span class="go">  &lt;child3/&gt;</span>
<span class="go">&lt;/root&gt;</span>
</pre></div>
</div>
<div class="section" id="elements-are-lists">
<h3><a class="toc-backref" href="#id4">Elements are lists</a><a class="headerlink" href="#elements-are-lists" title="Permalink to this headline">Â¶</a></h3>
<p>To make the access to these subelements easy and straight forward,
elements mimic the behaviour of normal Python lists as closely as
possible:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">child</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">child1</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
<span class="go">3</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># lxml.etree only!</span>
<span class="go">1</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">children</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">child1</span>
<span class="go">child2</span>
<span class="go">child3</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s2">&quot;child0&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">start</span> <span class="o">=</span> <span class="n">root</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">end</span>   <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">child0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">child3</span>
</pre></div>
</div>
<p>Prior to ElementTree 1.3 and lxml 2.0, you could also check the truth value of
an Element to see if it has children, i.e. if the list of children is empty:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">root</span><span class="p">:</span>   <span class="c1"># this no longer works!</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;The root element has children&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This is no longer supported as people tend to expect that a &#8220;something&#8221;
evaluates to True and expect Elements to be &#8220;something&#8221;, may they have
children or not.  So, many users find it surprising that any Element
would evaluate to False in an if-statement like the above.  Instead,
use <code class="docutils literal"><span class="pre">len(element)</span></code>, which is both more explicit and less error prone.</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">iselement</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>  <span class="c1"># test if it&#39;s some kind of Element</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>                 <span class="c1"># test if it has children</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;The root element has children&quot;</span><span class="p">)</span>
<span class="go">The root element has children</span>
</pre></div>
</div>
<p>There is another important case where the behaviour of Elements in lxml
(in 2.0 and later) deviates from that of lists and from that of the
original ElementTree (prior to version 1.3 or Python 2.7/3.2):</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">child0</span>
<span class="go">child1</span>
<span class="go">child2</span>
<span class="go">child3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># this moves the element in lxml.etree!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">child3</span>
<span class="go">child1</span>
<span class="go">child2</span>
</pre></div>
</div>
<p>In this example, the last element is <em>moved</em> to a different position,
instead of being copied, i.e. it is automatically removed from its
previous position when it is put in a different place.  In lists,
objects can appear in multiple positions at the same time, and the
above assignment would just copy the item reference into the first
position, so that both contain the exact same item:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span>
<span class="go">[3, 1, 2, 3]</span>
</pre></div>
</div>
<p>Note that in the original ElementTree, a single Element object can sit
in any number of places in any number of trees, which allows for the same
copy operation as with lists.  The obvious drawback is that modifications
to such an Element will apply to all places where it appears in a tree,
which may or may not be intended.</p>
<p>The upside of this difference is that an Element in <code class="docutils literal"><span class="pre">lxml.etree</span></code> always
has exactly one parent, which can be queried through the <code class="docutils literal"><span class="pre">getparent()</span></code>
method.  This is not supported in the original ElementTree.</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="ow">is</span> <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getparent</span><span class="p">()</span>  <span class="c1"># lxml.etree only!</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If you want to <em>copy</em> an element to a different position in <code class="docutils literal"><span class="pre">lxml.etree</span></code>,
consider creating an independent <em>deep copy</em> using the <code class="docutils literal"><span class="pre">copy</span></code> module
from Python&#8217;s standard library:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">element</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s2">&quot;neu&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">element</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">child1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">([</span> <span class="n">c</span><span class="o">.</span><span class="n">tag</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">root</span> <span class="p">])</span>
<span class="go">[&#39;child3&#39;, &#39;child1&#39;, &#39;child2&#39;]</span>
</pre></div>
</div>
<p>The siblings (or neighbours) of an element are accessed as next and previous
elements:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">getprevious</span><span class="p">()</span> <span class="c1"># lxml.etree only!</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getnext</span><span class="p">()</span> <span class="c1"># lxml.etree only!</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="elements-carry-attributes-as-a-dict">
<h3><a class="toc-backref" href="#id5">Elements carry attributes as a dict</a><a class="headerlink" href="#elements-carry-attributes-as-a-dict" title="Permalink to this headline">Â¶</a></h3>
<p>XML elements support attributes.  You can create them directly in the Element
factory:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s2">&quot;root&quot;</span><span class="p">,</span> <span class="n">interesting</span><span class="o">=</span><span class="s2">&quot;totally&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">b&#39;&lt;root interesting=&quot;totally&quot;/&gt;&#39;</span>
</pre></div>
</div>
<p>Attributes are just unordered name-value pairs, so a very convenient way
of dealing with them is through the dictionary-like interface of Elements:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;interesting&quot;</span><span class="p">))</span>
<span class="go">totally</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span> <span class="s2">&quot;Huhu&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">))</span>
<span class="go">Huhu</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">b&#39;&lt;root interesting=&quot;totally&quot; hello=&quot;Huhu&quot;/&gt;&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">[&#39;hello&#39;, &#39;interesting&#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
<span class="go">hello = &#39;Huhu&#39;</span>
<span class="go">interesting = &#39;totally&#39;</span>
</pre></div>
</div>
<p>For the cases where you want to do item lookup or have other reasons for
getting a &#8216;real&#8217; dictionary-like object, e.g. for passing it around,
you can use the <code class="docutils literal"><span class="pre">attrib</span></code> property:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">attributes</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">attributes</span><span class="p">[</span><span class="s2">&quot;interesting&quot;</span><span class="p">])</span>
<span class="go">totally</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">attributes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;no-such-attribute&quot;</span><span class="p">))</span>
<span class="go">None</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">attributes</span><span class="p">[</span><span class="s2">&quot;hello&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Guten Tag&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">attributes</span><span class="p">[</span><span class="s2">&quot;hello&quot;</span><span class="p">])</span>
<span class="go">Guten Tag</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">))</span>
<span class="go">Guten Tag</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal"><span class="pre">attrib</span></code> is a dict-like object backed by the Element itself.
This means that any changes to the Element are reflected in <code class="docutils literal"><span class="pre">attrib</span></code>
and vice versa.  It also means that the XML tree stays alive in memory
as long as the <code class="docutils literal"><span class="pre">attrib</span></code> of one of its Elements is in use.  To get an
independent snapshot of the attributes that does not depend on the XML
tree, copy it into a dict:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;hello&#39;, &#39;Guten Tag&#39;), (&#39;interesting&#39;, &#39;totally&#39;)]</span>
</pre></div>
</div>
</div>
<div class="section" id="elements-contain-text">
<h3><a class="toc-backref" href="#id6">Elements contain text</a><a class="headerlink" href="#elements-contain-text" title="Permalink to this headline">Â¶</a></h3>
<p>Elements can contain text:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s2">&quot;root&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;TEXT&quot;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="go">TEXT</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">b&#39;&lt;root&gt;TEXT&lt;/root&gt;&#39;</span>
</pre></div>
</div>
<p>In many XML documents (<em>data-centric</em> documents), this is the only place where
text can be found.  It is encapsulated by a leaf tag at the very bottom of the
tree hierarchy.</p>
<p>However, if XML is used for tagged text documents such as (X)HTML, text can
also appear between different elements, right in the middle of the tree:</p>
<div class="highlight-html"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;&lt;</span><span class="nt">body</span><span class="p">&gt;</span>Hello<span class="p">&lt;</span><span class="nt">br</span><span class="p">/&gt;</span>World<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Here, the <code class="docutils literal"><span class="pre">&lt;br/&gt;</span></code> tag is surrounded by text.  This is often referred to as
<em>document-style</em> or <em>mixed-content</em> XML.  Elements support this through their
<code class="docutils literal"><span class="pre">tail</span></code> property.  It contains the text that directly follows the element, up
to the next element in the XML tree:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">html</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s2">&quot;html&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">body</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">html</span><span class="p">,</span> <span class="s2">&quot;body&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">body</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;TEXT&quot;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>
<span class="go">b&#39;&lt;html&gt;&lt;body&gt;TEXT&lt;/body&gt;&lt;/html&gt;&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">br</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="s2">&quot;br&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>
<span class="go">b&#39;&lt;html&gt;&lt;body&gt;TEXT&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">br</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="s2">&quot;TAIL&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>
<span class="go">b&#39;&lt;html&gt;&lt;body&gt;TEXT&lt;br/&gt;TAIL&lt;/body&gt;&lt;/html&gt;&#39;</span>
</pre></div>
</div>
<p>The two properties <code class="docutils literal"><span class="pre">.text</span></code> and <code class="docutils literal"><span class="pre">.tail</span></code> are enough to represent any
text content in an XML document.  This way, the ElementTree API does
not require any <a class="reference external" href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-1312295772">special text nodes</a> in addition to the Element
class, that tend to get in the way fairly often (as you might know
from classic <a class="reference external" href="http://www.w3.org/TR/DOM-Level-3-Core/core.html">DOM</a> APIs).</p>
<p>However, there are cases where the tail text also gets in the way.
For example, when you serialise an Element from within the tree, you
do not always want its tail text in the result (although you would
still want the tail text of its children).  For this purpose, the
<code class="docutils literal"><span class="pre">tostring()</span></code> function accepts the keyword argument <code class="docutils literal"><span class="pre">with_tail</span></code>:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">br</span><span class="p">)</span>
<span class="go">b&#39;&lt;br/&gt;TAIL&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">with_tail</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># lxml.etree only!</span>
<span class="go">b&#39;&lt;br/&gt;&#39;</span>
</pre></div>
</div>
<p>If you want to read <em>only</em> the text, i.e. without any intermediate
tags, you have to recursively concatenate all <code class="docutils literal"><span class="pre">text</span></code> and <code class="docutils literal"><span class="pre">tail</span></code>
attributes in the correct order.  Again, the <code class="docutils literal"><span class="pre">tostring()</span></code> function
comes to the rescue, this time using the <code class="docutils literal"><span class="pre">method</span></code> keyword:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">html</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">)</span>
<span class="go">b&#39;TEXTTAIL&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="using-xpath-to-find-text">
<h3><a class="toc-backref" href="#id7">Using XPath to find text</a><a class="headerlink" href="#using-xpath-to-find-text" title="Permalink to this headline">Â¶</a></h3>
<p>Another way to extract the text content of a tree is <a class="reference external" href="xpathxslt.html#xpath">XPath</a>, which
also allows you to extract the separate text chunks into a list:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">html</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s2">&quot;string()&quot;</span><span class="p">))</span> <span class="c1"># lxml.etree only!</span>
<span class="go">TEXTTAIL</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">html</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s2">&quot;//text()&quot;</span><span class="p">))</span> <span class="c1"># lxml.etree only!</span>
<span class="go">[&#39;TEXT&#39;, &#39;TAIL&#39;]</span>
</pre></div>
</div>
<p>If you want to use this more often, you can wrap it in a function:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">build_text_list</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XPath</span><span class="p">(</span><span class="s2">&quot;//text()&quot;</span><span class="p">)</span> <span class="c1"># lxml.etree only!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">build_text_list</span><span class="p">(</span><span class="n">html</span><span class="p">))</span>
<span class="go">[&#39;TEXT&#39;, &#39;TAIL&#39;]</span>
</pre></div>
</div>
<p>Note that a string result returned by XPath is a special &#8216;smart&#8217;
object that knows about its origins.  You can ask it where it came
from through its <code class="docutils literal"><span class="pre">getparent()</span></code> method, just as you would with
Elements:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">texts</span> <span class="o">=</span> <span class="n">build_text_list</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">texts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">TEXT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parent</span> <span class="o">=</span> <span class="n">texts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getparent</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">body</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">texts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">TAIL</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">texts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">getparent</span><span class="p">()</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">br</span>
</pre></div>
</div>
<p>You can also find out if it&#8217;s normal text content or tail text:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">texts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_text</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">texts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_text</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">texts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_tail</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>While this works for the results of the <code class="docutils literal"><span class="pre">text()</span></code> function, lxml will
not tell you the origin of a string value that was constructed by the
XPath functions <code class="docutils literal"><span class="pre">string()</span></code> or <code class="docutils literal"><span class="pre">concat()</span></code>:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stringify</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XPath</span><span class="p">(</span><span class="s2">&quot;string()&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">stringify</span><span class="p">(</span><span class="n">html</span><span class="p">))</span>
<span class="go">TEXTTAIL</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">stringify</span><span class="p">(</span><span class="n">html</span><span class="p">)</span><span class="o">.</span><span class="n">getparent</span><span class="p">())</span>
<span class="go">None</span>
</pre></div>
</div>
</div>
<div class="section" id="tree-iteration">
<h3><a class="toc-backref" href="#id8">Tree iteration</a><a class="headerlink" href="#tree-iteration" title="Permalink to this headline">Â¶</a></h3>
<p>For problems like the above, where you want to recursively traverse the tree
and do something with its elements, tree iteration is a very convenient
solution.  Elements provide a tree iterator for this purpose.  It yields
elements in <em>document order</em>, i.e. in the order their tags would appear if you
serialised the tree to XML:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s2">&quot;root&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;child&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Child 1&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;child&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Child 2&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;another&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Child 3&quot;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">&lt;root&gt;</span>
<span class="go">  &lt;child&gt;Child 1&lt;/child&gt;</span>
<span class="go">  &lt;child&gt;Child 2&lt;/child&gt;</span>
<span class="go">  &lt;another&gt;Child 3&lt;/another&gt;</span>
<span class="go">&lt;/root&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">text</span><span class="p">))</span>
<span class="go">root - None</span>
<span class="go">child - Child 1</span>
<span class="go">child - Child 2</span>
<span class="go">another - Child 3</span>
</pre></div>
</div>
<p>If you know you are only interested in a single tag, you can pass its name to
<code class="docutils literal"><span class="pre">iter()</span></code> to have it filter for you.  Starting with lxml 3.0, you can also
pass more than one tag to intercept on multiple tags during iteration.</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s2">&quot;child&quot;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">text</span><span class="p">))</span>
<span class="go">child - Child 1</span>
<span class="go">child - Child 2</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s2">&quot;another&quot;</span><span class="p">,</span> <span class="s2">&quot;child&quot;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">text</span><span class="p">))</span>
<span class="go">child - Child 1</span>
<span class="go">child - Child 2</span>
<span class="go">another - Child 3</span>
</pre></div>
</div>
<p>By default, iteration yields all nodes in the tree, including
ProcessingInstructions, Comments and Entity instances.  If you want to
make sure only Element objects are returned, you can pass the
<code class="docutils literal"><span class="pre">Element</span></code> factory as tag parameter:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">Entity</span><span class="p">(</span><span class="s2">&quot;#234&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">Comment</span><span class="p">(</span><span class="s2">&quot;some comment&quot;</span><span class="p">))</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>  <span class="c1"># or &#39;str&#39; in Python 3</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">text</span><span class="p">))</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;SPECIAL: </span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">text</span><span class="p">))</span>
<span class="go">root - None</span>
<span class="go">child - Child 1</span>
<span class="go">child - Child 2</span>
<span class="go">another - Child 3</span>
<span class="go">SPECIAL: &amp;#234; - &amp;#234;</span>
<span class="go">SPECIAL: &lt;!--some comment--&gt; - some comment</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">text</span><span class="p">))</span>
<span class="go">root - None</span>
<span class="go">child - Child 1</span>
<span class="go">child - Child 2</span>
<span class="go">another - Child 3</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="n">etree</span><span class="o">.</span><span class="n">Entity</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="go">&amp;#234;</span>
</pre></div>
</div>
<p>Note that passing a wildcard <code class="docutils literal"><span class="pre">&quot;*&quot;</span></code> tag name will also yield all
<code class="docutils literal"><span class="pre">Element</span></code> nodes (and only elements).</p>
<p>In <code class="docutils literal"><span class="pre">lxml.etree</span></code>, elements provide <a class="reference external" href="api.html#iteration">further iterators</a> for all directions in the
tree: children, parents (or rather ancestors) and siblings.</p>
</div>
<div class="section" id="serialisation">
<h3><a class="toc-backref" href="#id9">Serialisation</a><a class="headerlink" href="#serialisation" title="Permalink to this headline">Â¶</a></h3>
<p>Serialisation commonly uses the <code class="docutils literal"><span class="pre">tostring()</span></code> function that returns a
string, or the <code class="docutils literal"><span class="pre">ElementTree.write()</span></code> method that writes to a file, a
file-like object, or a URL (via FTP PUT or HTTP POST).  Both calls accept
the same keyword arguments like <code class="docutils literal"><span class="pre">pretty_print</span></code> for formatted output
or <code class="docutils literal"><span class="pre">encoding</span></code> to select a specific output encoding other than plain
ASCII:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XML</span><span class="p">(</span><span class="s1">&#39;&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">b&#39;&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">xml_declaration</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">&lt;?xml version=&#39;1.0&#39; encoding=&#39;ASCII&#39;?&gt;</span>
<span class="go">&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;iso-8859-1&#39;</span><span class="p">))</span>
<span class="go">&lt;?xml version=&#39;1.0&#39; encoding=&#39;iso-8859-1&#39;?&gt;</span>
<span class="go">&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">&lt;root&gt;</span>
<span class="go">  &lt;a&gt;</span>
<span class="go">    &lt;b/&gt;</span>
<span class="go">  &lt;/a&gt;</span>
<span class="go">&lt;/root&gt;</span>
</pre></div>
</div>
<p>Note that pretty printing appends a newline at the end.</p>
<p>In lxml 2.0 and later (as well as ElementTree 1.3), the serialisation
functions can do more than XML serialisation.  You can serialise to
HTML or extract the text content by passing the <code class="docutils literal"><span class="pre">method</span></code> keyword:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XML</span><span class="p">(</span>
<span class="gp">... </span>   <span class="s1">&#39;&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Hello&lt;br/&gt;World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="c1"># default: method = &#39;xml&#39;</span>
<span class="go">b&#39;&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Hello&lt;br/&gt;World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;xml&#39;</span><span class="p">)</span> <span class="c1"># same as above</span>
<span class="go">b&#39;&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Hello&lt;br/&gt;World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;html&#39;</span><span class="p">)</span>
<span class="go">b&#39;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Hello&lt;br&gt;World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;html&#39;</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">&lt;html&gt;</span>
<span class="go">&lt;head&gt;&lt;/head&gt;</span>
<span class="go">&lt;body&gt;&lt;p&gt;Hello&lt;br&gt;World&lt;/p&gt;&lt;/body&gt;</span>
<span class="go">&lt;/html&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;text&#39;</span><span class="p">)</span>
<span class="go">b&#39;HelloWorld&#39;</span>
</pre></div>
</div>
<p>As for XML serialisation, the default encoding for plain text
serialisation is ASCII:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">br</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s1">&#39;br&#39;</span><span class="p">))</span>  <span class="c1"># get first result of iteration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">br</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;W</span><span class="se">\xf6</span><span class="s1">rld&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;text&#39;</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">UnicodeEncodeError</span>: <span class="n">&#39;ascii&#39; codec can&#39;t encode character u&#39;\xf6&#39; ...</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;text&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;UTF-8&quot;</span><span class="p">)</span>
<span class="go">b&#39;HelloW\xc3\xb6rld&#39;</span>
</pre></div>
</div>
<p>Here, serialising to a Python unicode string instead of a byte string
might become handy.  Just pass the name <code class="docutils literal"><span class="pre">'unicode'</span></code> as encoding:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;unicode&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;text&#39;</span><span class="p">)</span>
<span class="go">u&#39;HelloW\xf6rld&#39;</span>
</pre></div>
</div>
<p>The W3C has a good <a class="reference external" href="http://www.w3.org/International/tutorials/tutorial-char-enc/">article about the Unicode character set and
character encodings</a>.</p>
</div>
</div>
<div class="section" id="the-elementtree-class">
<h2><a class="toc-backref" href="#id10">The ElementTree class</a><a class="headerlink" href="#the-elementtree-class" title="Permalink to this headline">Â¶</a></h2>
<p>An <code class="docutils literal"><span class="pre">ElementTree</span></code> is mainly a document wrapper around a tree with a
root node.  It provides a couple of methods for serialisation and
general document handling.</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XML</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="gp">... </span><span class="s1">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="gp">... </span><span class="s1">&lt;!DOCTYPE root SYSTEM &quot;test&quot; [ &lt;!ENTITY tasty &quot;parsnips&quot;&gt; ]&gt;</span>
<span class="gp">... </span><span class="s1">&lt;root&gt;</span>
<span class="gp">... </span><span class="s1">  &lt;a&gt;&amp;tasty;&lt;/a&gt;</span>
<span class="gp">... </span><span class="s1">&lt;/root&gt;</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">ElementTree</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">docinfo</span><span class="o">.</span><span class="n">xml_version</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">docinfo</span><span class="o">.</span><span class="n">doctype</span><span class="p">)</span>
<span class="go">&lt;!DOCTYPE root SYSTEM &quot;test&quot;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">docinfo</span><span class="o">.</span><span class="n">public_id</span> <span class="o">=</span> <span class="s1">&#39;-//W3C//DTD XHTML 1.0 Transitional//EN&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">docinfo</span><span class="o">.</span><span class="n">system_url</span> <span class="o">=</span> <span class="s1">&#39;file://local.dtd&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">docinfo</span><span class="o">.</span><span class="n">doctype</span><span class="p">)</span>
<span class="go">&lt;!DOCTYPE root PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;file://local.dtd&quot;&gt;</span>
</pre></div>
</div>
<p>An <code class="docutils literal"><span class="pre">ElementTree</span></code> is also what you get back when you call the
<code class="docutils literal"><span class="pre">parse()</span></code> function to parse files or file-like objects (see the
parsing section below).</p>
<p>One of the important differences is that the <code class="docutils literal"><span class="pre">ElementTree</span></code> class
serialises as a complete document, as opposed to a single <code class="docutils literal"><span class="pre">Element</span></code>.
This includes top-level processing instructions and comments, as well
as a DOCTYPE and other DTD content in the document:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>  <span class="c1"># lxml 1.3.4 and later</span>
<span class="go">&lt;!DOCTYPE root PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;file://local.dtd&quot; [</span>
<span class="go">&lt;!ENTITY tasty &quot;parsnips&quot;&gt;</span>
<span class="go">]&gt;</span>
<span class="go">&lt;root&gt;</span>
<span class="go">  &lt;a&gt;parsnips&lt;/a&gt;</span>
<span class="go">&lt;/root&gt;</span>
</pre></div>
</div>
<p>In the original xml.etree.ElementTree implementation and in lxml
up to 1.3.3, the output looks the same as when serialising only
the root Element:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()))</span>
<span class="go">&lt;root&gt;</span>
<span class="go">  &lt;a&gt;parsnips&lt;/a&gt;</span>
<span class="go">&lt;/root&gt;</span>
</pre></div>
</div>
<p>This serialisation behaviour has changed in lxml 1.3.4.  Before,
the tree was serialised without DTD content, which made lxml
lose DTD information in an input-output cycle.</p>
</div>
<div class="section" id="parsing-from-strings-and-files">
<h2><a class="toc-backref" href="#id11">Parsing from strings and files</a><a class="headerlink" href="#parsing-from-strings-and-files" title="Permalink to this headline">Â¶</a></h2>
<p><code class="docutils literal"><span class="pre">lxml.etree</span></code> supports parsing XML in a number of ways and from all
important sources, namely strings, files, URLs (http/ftp) and
file-like objects.  The main parse functions are <code class="docutils literal"><span class="pre">fromstring()</span></code> and
<code class="docutils literal"><span class="pre">parse()</span></code>, both called with the source as first argument.  By
default, they use the standard parser, but you can always pass a
different parser as second argument.</p>
<div class="section" id="the-fromstring-function">
<h3><a class="toc-backref" href="#id12">The fromstring() function</a><a class="headerlink" href="#the-fromstring-function" title="Permalink to this headline">Â¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">fromstring()</span></code> function is the easiest way to parse a string:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">some_xml_data</span> <span class="o">=</span> <span class="s2">&quot;&lt;root&gt;data&lt;/root&gt;&quot;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">some_xml_data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">root</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">b&#39;&lt;root&gt;data&lt;/root&gt;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="the-xml-function">
<h3><a class="toc-backref" href="#id13">The XML() function</a><a class="headerlink" href="#the-xml-function" title="Permalink to this headline">Â¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">XML()</span></code> function behaves like the <code class="docutils literal"><span class="pre">fromstring()</span></code> function, but is
commonly used to write XML literals right into the source:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XML</span><span class="p">(</span><span class="s2">&quot;&lt;root&gt;data&lt;/root&gt;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">root</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">b&#39;&lt;root&gt;data&lt;/root&gt;&#39;</span>
</pre></div>
</div>
<p>There is also a corresponding function <code class="docutils literal"><span class="pre">HTML()</span></code> for HTML literals.</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">HTML</span><span class="p">(</span><span class="s2">&quot;&lt;p&gt;data&lt;/p&gt;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">b&#39;&lt;html&gt;&lt;body&gt;&lt;p&gt;data&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="the-parse-function">
<h3><a class="toc-backref" href="#id14">The parse() function</a><a class="headerlink" href="#the-parse-function" title="Permalink to this headline">Â¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">parse()</span></code> function is used to parse from files and file-like objects.</p>
<p>As an example of such a file-like object, the following code uses the
<code class="docutils literal"><span class="pre">BytesIO</span></code> class for reading from a string instead of an external file.
That class comes from the <code class="docutils literal"><span class="pre">io</span></code> module in Python 2.6 and later.  In older
Python versions, you will have to use the <code class="docutils literal"><span class="pre">StringIO</span></code> class from the
<code class="docutils literal"><span class="pre">StringIO</span></code> module.  However, in real life, you would obviously avoid
doing this all together and use the string parsing functions above.</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">some_file_or_file_like_object</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&lt;root&gt;data&lt;/root&gt;&quot;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">some_file_or_file_like_object</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="go">b&#39;&lt;root&gt;data&lt;/root&gt;&#39;</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal"><span class="pre">parse()</span></code> returns an ElementTree object, not an Element object as
the string parser functions:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">root</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">b&#39;&lt;root&gt;data&lt;/root&gt;&#39;</span>
</pre></div>
</div>
<p>The reasoning behind this difference is that <code class="docutils literal"><span class="pre">parse()</span></code> returns a
complete document from a file, while the string parsing functions are
commonly used to parse XML fragments.</p>
<p>The <code class="docutils literal"><span class="pre">parse()</span></code> function supports any of the following sources:</p>
<ul class="simple">
<li>an open file object (make sure to open it in binary mode)</li>
<li>a file-like object that has a <code class="docutils literal"><span class="pre">.read(byte_count)</span></code> method returning
a byte string on each call</li>
<li>a filename string</li>
<li>an HTTP or FTP URL string</li>
</ul>
<p>Note that passing a filename or URL is usually faster than passing an
open file or file-like object.  However, the HTTP/FTP client in libxml2
is rather simple, so things like HTTP authentication require a dedicated
URL request library, e.g. <code class="docutils literal"><span class="pre">urllib2</span></code> or <code class="docutils literal"><span class="pre">request</span></code>.  These libraries
usually provide a file-like object for the result that you can parse
from while the response is streaming in.</p>
</div>
<div class="section" id="parser-objects">
<h3><a class="toc-backref" href="#id15">Parser objects</a><a class="headerlink" href="#parser-objects" title="Permalink to this headline">Â¶</a></h3>
<p>By default, <code class="docutils literal"><span class="pre">lxml.etree</span></code> uses a standard parser with a default setup.  If
you want to configure the parser, you can create a new instance:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XMLParser</span><span class="p">(</span><span class="n">remove_blank_text</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c1"># lxml.etree only!</span>
</pre></div>
</div>
<p>This creates a parser that removes empty text between tags while parsing,
which can reduce the size of the tree and avoid dangling tail text if you know
that whitespace-only content is not meaningful for your data.  An example:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XML</span><span class="p">(</span><span class="s2">&quot;&lt;root&gt;  &lt;a/&gt;   &lt;b&gt;  &lt;/b&gt;     &lt;/root&gt;&quot;</span><span class="p">,</span> <span class="n">parser</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">b&#39;&lt;root&gt;&lt;a/&gt;&lt;b&gt;  &lt;/b&gt;&lt;/root&gt;&#39;</span>
</pre></div>
</div>
<p>Note that the whitespace content inside the <code class="docutils literal"><span class="pre">&lt;b&gt;</span></code> tag was not removed, as
content at leaf elements tends to be data content (even if blank).  You can
easily remove it in an additional step by traversing the tree:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">text</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">element</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
<span class="gp">... </span>        <span class="n">element</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="bp">None</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">b&#39;&lt;root&gt;&lt;a/&gt;&lt;b/&gt;&lt;/root&gt;&#39;</span>
</pre></div>
</div>
<p>See <code class="docutils literal"><span class="pre">help(etree.XMLParser)</span></code> to find out about the available parser options.</p>
</div>
<div class="section" id="incremental-parsing">
<h3><a class="toc-backref" href="#id16">Incremental parsing</a><a class="headerlink" href="#incremental-parsing" title="Permalink to this headline">Â¶</a></h3>
<p><code class="docutils literal"><span class="pre">lxml.etree</span></code> provides two ways for incremental step-by-step parsing.  One is
through file-like objects, where it calls the <code class="docutils literal"><span class="pre">read()</span></code> method repeatedly.
This is best used where the data arrives from a source like <code class="docutils literal"><span class="pre">urllib</span></code> or any
other file-like object that can provide data on request.  Note that the parser
will block and wait until data becomes available in this case:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">DataSource</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span> <span class="sa">b</span><span class="s2">&quot;&lt;roo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;t&gt;&lt;&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;a/&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;&gt;&lt;&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;/root&gt;&quot;</span> <span class="p">]</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">requested_size</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">return</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">DataSource</span><span class="p">())</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="go">b&#39;&lt;root&gt;&lt;a/&gt;&lt;/root&gt;&#39;</span>
</pre></div>
</div>
<p>The second way is through a feed parser interface, given by the <code class="docutils literal"><span class="pre">feed(data)</span></code>
and <code class="docutils literal"><span class="pre">close()</span></code> methods:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XMLParser</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">feed</span><span class="p">(</span><span class="s2">&quot;&lt;roo&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">feed</span><span class="p">(</span><span class="s2">&quot;t&gt;&lt;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">feed</span><span class="p">(</span><span class="s2">&quot;a/&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">feed</span><span class="p">(</span><span class="s2">&quot;&gt;&lt;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">feed</span><span class="p">(</span><span class="s2">&quot;/root&gt;&quot;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">b&#39;&lt;root&gt;&lt;a/&gt;&lt;/root&gt;&#39;</span>
</pre></div>
</div>
<p>Here, you can interrupt the parsing process at any time and continue it later
on with another call to the <code class="docutils literal"><span class="pre">feed()</span></code> method.  This comes in handy if you
want to avoid blocking calls to the parser, e.g. in frameworks like Twisted,
or whenever data comes in slowly or in chunks and you want to do other things
while waiting for the next chunk.</p>
<p>After calling the <code class="docutils literal"><span class="pre">close()</span></code> method (or when an exception was raised
by the parser), you can reuse the parser by calling its <code class="docutils literal"><span class="pre">feed()</span></code>
method again:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">feed</span><span class="p">(</span><span class="s2">&quot;&lt;root/&gt;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="go">b&#39;&lt;root/&gt;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="event-driven-parsing">
<h3><a class="toc-backref" href="#id17">Event-driven parsing</a><a class="headerlink" href="#event-driven-parsing" title="Permalink to this headline">Â¶</a></h3>
<p>Sometimes, all you need from a document is a small fraction somewhere deep
inside the tree, so parsing the whole tree into memory, traversing it and
dropping it can be too much overhead.  <code class="docutils literal"><span class="pre">lxml.etree</span></code> supports this use case
with two event-driven parser interfaces, one that generates parser events
while building the tree (<code class="docutils literal"><span class="pre">iterparse</span></code>), and one that does not build the tree
at all, and instead calls feedback methods on a target object in a SAX-like
fashion.</p>
<p>Here is a simple <code class="docutils literal"><span class="pre">iterparse()</span></code> example:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">some_file_like</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&lt;root&gt;&lt;a&gt;data&lt;/a&gt;&lt;/root&gt;&quot;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">event</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">etree</span><span class="o">.</span><span class="n">iterparse</span><span class="p">(</span><span class="n">some_file_like</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">, </span><span class="si">%4s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">text</span><span class="p">))</span>
<span class="go">end,    a, data</span>
<span class="go">end, root, None</span>
</pre></div>
</div>
<p>By default, <code class="docutils literal"><span class="pre">iterparse()</span></code> only generates events when it is done parsing an
element, but you can control this through the <code class="docutils literal"><span class="pre">events</span></code> keyword argument:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">some_file_like</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&lt;root&gt;&lt;a&gt;data&lt;/a&gt;&lt;/root&gt;&quot;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">event</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">etree</span><span class="o">.</span><span class="n">iterparse</span><span class="p">(</span><span class="n">some_file_like</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="n">events</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%5s</span><span class="s2">, </span><span class="si">%4s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">text</span><span class="p">))</span>
<span class="go">start, root, None</span>
<span class="go">start,    a, data</span>
<span class="go">  end,    a, data</span>
<span class="go">  end, root, None</span>
</pre></div>
</div>
<p>Note that the text, tail, and children of an Element are not necessarily present
yet when receiving the <code class="docutils literal"><span class="pre">start</span></code> event.  Only the <code class="docutils literal"><span class="pre">end</span></code> event guarantees
that the Element has been parsed completely.</p>
<p>It also allows you to <code class="docutils literal"><span class="pre">.clear()</span></code> or modify the content of an Element to
save memory. So if you parse a large tree and you want to keep memory
usage small, you should clean up parts of the tree that you no longer
need:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">some_file_like</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">(</span>
<span class="gp">... </span>    <span class="sa">b</span><span class="s2">&quot;&lt;root&gt;&lt;a&gt;&lt;b&gt;data&lt;/b&gt;&lt;/a&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;&quot;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">event</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">etree</span><span class="o">.</span><span class="n">iterparse</span><span class="p">(</span><span class="n">some_file_like</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">elif</span> <span class="n">element</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;** cleaning up the subtree&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">element</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="go">data</span>
<span class="go">** cleaning up the subtree</span>
<span class="go">None</span>
<span class="go">** cleaning up the subtree</span>
</pre></div>
</div>
<p>A very important use case for <code class="docutils literal"><span class="pre">iterparse()</span></code> is parsing large
generated XML files, e.g. database dumps.  Most often, these XML
formats only have one main data item element that hangs directly below
the root node and that is repeated thousands of times.  In this case,
it is best practice to let <code class="docutils literal"><span class="pre">lxml.etree</span></code> do the tree building and only to
intercept on exactly this one Element, using the normal tree API
for data extraction.</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xml_file</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="gp">... </span><span class="s1">&lt;root&gt;</span>
<span class="gp">... </span><span class="s1">  &lt;a&gt;&lt;b&gt;ABC&lt;/b&gt;&lt;c&gt;abc&lt;/c&gt;&lt;/a&gt;</span>
<span class="gp">... </span><span class="s1">  &lt;a&gt;&lt;b&gt;MORE DATA&lt;/b&gt;&lt;c&gt;more data&lt;/c&gt;&lt;/a&gt;</span>
<span class="gp">... </span><span class="s1">  &lt;a&gt;&lt;b&gt;XYZ&lt;/b&gt;&lt;c&gt;xyz&lt;/c&gt;&lt;/a&gt;</span>
<span class="gp">... </span><span class="s1">&lt;/root&gt;&#39;&#39;&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">etree</span><span class="o">.</span><span class="n">iterparse</span><span class="p">(</span><span class="n">xml_file</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> -- </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">findtext</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="n">element</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">element</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="go">ABC -- abc</span>
<span class="go">MORE DATA -- more data</span>
<span class="go">XYZ -- xyz</span>
</pre></div>
</div>
<p>If, for some reason, building the tree is not desired at all, the
target parser interface of <code class="docutils literal"><span class="pre">lxml.etree</span></code> can be used.  It creates
SAX-like events by calling the methods of a target object.  By
implementing some or all of these methods, you can control which
events are generated:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">ParserTarget</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">events</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">... </span>    <span class="n">close_count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">attrib</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">attrib</span><span class="p">))</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">events</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">,</span> <span class="p">[]</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">close_count</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">events</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">parser_target</span> <span class="o">=</span> <span class="n">ParserTarget</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XMLParser</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">parser_target</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">events</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="s1">&#39;&lt;root test=&quot;true&quot;/&gt;&#39;</span><span class="p">,</span> <span class="n">parser</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">parser_target</span><span class="o">.</span><span class="n">close_count</span><span class="p">)</span>
<span class="go">1</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;event: </span><span class="si">%s</span><span class="s1"> - tag: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">event</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="s1">&#39; * </span><span class="si">%s</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
<span class="go">event: start - tag: root</span>
<span class="go"> * test = true</span>
</pre></div>
</div>
<p>You can reuse the parser and its target as often as you like, so you
should take care that the <code class="docutils literal"><span class="pre">.close()</span></code> method really resets the
target to a usable state (also in the case of an error!).</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">events</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="s1">&#39;&lt;root test=&quot;true&quot;/&gt;&#39;</span><span class="p">,</span> <span class="n">parser</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">parser_target</span><span class="o">.</span><span class="n">close_count</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">events</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="s1">&#39;&lt;root test=&quot;true&quot;/&gt;&#39;</span><span class="p">,</span> <span class="n">parser</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">parser_target</span><span class="o">.</span><span class="n">close_count</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">events</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="s1">&#39;&lt;root test=&quot;true&quot;/&gt;&#39;</span><span class="p">,</span> <span class="n">parser</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">parser_target</span><span class="o">.</span><span class="n">close_count</span><span class="p">)</span>
<span class="go">4</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;event: </span><span class="si">%s</span><span class="s1"> - tag: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">event</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="s1">&#39; * </span><span class="si">%s</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
<span class="go">event: start - tag: root</span>
<span class="go"> * test = true</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="namespaces">
<h2><a class="toc-backref" href="#id18">Namespaces</a><a class="headerlink" href="#namespaces" title="Permalink to this headline">Â¶</a></h2>
<p>The ElementTree API avoids
<a class="reference external" href="http://www.w3.org/TR/xml-names/#ns-qualnames">namespace prefixes</a>
wherever possible and deploys the real namespace (the URI) instead:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xhtml</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s2">&quot;{http://www.w3.org/1999/xhtml}html&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">body</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xhtml</span><span class="p">,</span> <span class="s2">&quot;{http://www.w3.org/1999/xhtml}body&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">body</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Hello World&quot;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">xhtml</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">&lt;html:html xmlns:html=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span>
<span class="go">  &lt;html:body&gt;Hello World&lt;/html:body&gt;</span>
<span class="go">&lt;/html:html&gt;</span>
</pre></div>
</div>
<p>The notation that ElementTree uses was originally brought up by
<a class="reference external" href="http://www.jclark.com/xml/xmlns.htm">James Clark</a>.  It has the major
advantage of providing a universally qualified name for a tag, regardless
of any prefixes that may or may not have been used or defined in a document.
By moving the indirection of prefixes out of the way, it makes namespace
aware code much clearer and easier to get right.</p>
<p>As you can see from the example, prefixes only become important when
you serialise the result.  However, the above code looks somewhat
verbose due to the lengthy namespace names.  And retyping or copying a
string over and over again is error prone.  It is therefore common
practice to store a namespace URI in a global variable.  To adapt the
namespace prefixes for serialisation, you can also pass a mapping to
the Element factory function, e.g. to define the default namespace:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">XHTML_NAMESPACE</span> <span class="o">=</span> <span class="s2">&quot;http://www.w3.org/1999/xhtml&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">XHTML</span> <span class="o">=</span> <span class="s2">&quot;{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="n">XHTML_NAMESPACE</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">NSMAP</span> <span class="o">=</span> <span class="p">{</span><span class="bp">None</span> <span class="p">:</span> <span class="n">XHTML_NAMESPACE</span><span class="p">}</span> <span class="c1"># the default namespace (no prefix)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">xhtml</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="n">XHTML</span> <span class="o">+</span> <span class="s2">&quot;html&quot;</span><span class="p">,</span> <span class="n">nsmap</span><span class="o">=</span><span class="n">NSMAP</span><span class="p">)</span> <span class="c1"># lxml only!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">body</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">xhtml</span><span class="p">,</span> <span class="n">XHTML</span> <span class="o">+</span> <span class="s2">&quot;body&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">body</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Hello World&quot;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">xhtml</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span>
<span class="go">  &lt;body&gt;Hello World&lt;/body&gt;</span>
<span class="go">&lt;/html&gt;</span>
</pre></div>
</div>
<p>You can also use the <code class="docutils literal"><span class="pre">QName</span></code> helper class to build or split qualified
tag names:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tag</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">QName</span><span class="p">(</span><span class="s1">&#39;http://www.w3.org/1999/xhtml&#39;</span><span class="p">,</span> <span class="s1">&#39;html&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">localname</span><span class="p">)</span>
<span class="go">html</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">namespace</span><span class="p">)</span>
<span class="go">http://www.w3.org/1999/xhtml</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="go">{http://www.w3.org/1999/xhtml}html</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">tag</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">QName</span><span class="p">(</span><span class="s1">&#39;{http://www.w3.org/1999/xhtml}html&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">localname</span><span class="p">)</span>
<span class="go">html</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">namespace</span><span class="p">)</span>
<span class="go">http://www.w3.org/1999/xhtml</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;{http://www.w3.org/1999/xhtml}html&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tag</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">QName</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">localname</span><span class="p">)</span>
<span class="go">html</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">tag</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">QName</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;script&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="go">{http://www.w3.org/1999/xhtml}script</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tag</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">QName</span><span class="p">(</span><span class="s1">&#39;{http://www.w3.org/1999/xhtml}html&#39;</span><span class="p">,</span> <span class="s1">&#39;script&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="go">{http://www.w3.org/1999/xhtml}script</span>
</pre></div>
</div>
<p>lxml.etree allows you to look up the current namespaces defined for a
node through the <code class="docutils literal"><span class="pre">.nsmap</span></code> property:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xhtml</span><span class="o">.</span><span class="n">nsmap</span>
<span class="go">{None: &#39;http://www.w3.org/1999/xhtml&#39;}</span>
</pre></div>
</div>
<p>Note, however, that this includes all prefixes known in the context of
an Element, not only those that it defines itself.</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;root&#39;</span><span class="p">,</span> <span class="n">nsmap</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;http://a.b/c&#39;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">child</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;child&#39;</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">nsmap</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s1">&#39;http://b.c/d&#39;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">nsmap</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">nsmap</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">child</span><span class="o">.</span><span class="n">nsmap</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="go">&#39;http://a.b/c&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">child</span><span class="o">.</span><span class="n">nsmap</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="go">&#39;http://b.c/d&#39;</span>
</pre></div>
</div>
<p>Therefore, modifying the returned dict cannot have any meaningful
impact on the Element.  Any changes to it are ignored.</p>
<p>Namespaces on attributes work alike, but as of version 2.3, <code class="docutils literal"><span class="pre">lxml.etree</span></code>
will ensure that the attribute uses a prefixed namespace
declaration.  This is because unprefixed attribute names are not
considered being in a namespace by the XML namespace specification
(<a class="reference external" href="http://www.w3.org/TR/2009/REC-xml-names-20091208/#defaulting">section 6.2</a>), so they may end up losing their namespace on a
serialise-parse roundtrip, even if they appear in a namespaced
element.</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">body</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">XHTML</span> <span class="o">+</span> <span class="s2">&quot;bgcolor&quot;</span><span class="p">,</span> <span class="s2">&quot;#CCFFAA&quot;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">xhtml</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span>
<span class="go">  &lt;body xmlns:html=&quot;http://www.w3.org/1999/xhtml&quot; html:bgcolor=&quot;#CCFFAA&quot;&gt;Hello World&lt;/body&gt;</span>
<span class="go">&lt;/html&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bgcolor&quot;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">body</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">XHTML</span> <span class="o">+</span> <span class="s2">&quot;bgcolor&quot;</span><span class="p">)</span>
<span class="go">&#39;#CCFFAA&#39;</span>
</pre></div>
</div>
<p>You can also use XPath with fully qualified names:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">find_xhtml_body</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">ETXPath</span><span class="p">(</span>      <span class="c1"># lxml only !</span>
<span class="gp">... </span>    <span class="s2">&quot;//{</span><span class="si">%s</span><span class="s2">}body&quot;</span> <span class="o">%</span> <span class="n">XHTML_NAMESPACE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">find_xhtml_body</span><span class="p">(</span><span class="n">xhtml</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">{http://www.w3.org/1999/xhtml}body</span>
</pre></div>
</div>
<p>For convenience, you can use <code class="docutils literal"><span class="pre">&quot;*&quot;</span></code> wildcards in all iterators of <code class="docutils literal"><span class="pre">lxml.etree</span></code>,
both for tag names and namespaces:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">xhtml</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>   <span class="c1"># any element</span>
<span class="go">{http://www.w3.org/1999/xhtml}html</span>
<span class="go">{http://www.w3.org/1999/xhtml}body</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">xhtml</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s1">&#39;{http://www.w3.org/1999/xhtml}*&#39;</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">{http://www.w3.org/1999/xhtml}html</span>
<span class="go">{http://www.w3.org/1999/xhtml}body</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">xhtml</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s1">&#39;{*}body&#39;</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">{http://www.w3.org/1999/xhtml}body</span>
</pre></div>
</div>
<p>To look for elements that do not have a namespace, either use the
plain tag name or provide the empty namespace explicitly:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span> <span class="n">el</span><span class="o">.</span><span class="n">tag</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">xhtml</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s1">&#39;{http://www.w3.org/1999/xhtml}body&#39;</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[&#39;{http://www.w3.org/1999/xhtml}body&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span> <span class="n">el</span><span class="o">.</span><span class="n">tag</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">xhtml</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s1">&#39;body&#39;</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span> <span class="n">el</span><span class="o">.</span><span class="n">tag</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">xhtml</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s1">&#39;{}body&#39;</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span> <span class="n">el</span><span class="o">.</span><span class="n">tag</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">xhtml</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s1">&#39;{}*&#39;</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[]</span>
</pre></div>
</div>
</div>
<div class="section" id="the-e-factory">
<h2><a class="toc-backref" href="#id19">The E-factory</a><a class="headerlink" href="#the-e-factory" title="Permalink to this headline">Â¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">E-factory</span></code> provides a simple and compact syntax for generating XML and
HTML:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lxml.builder</span> <span class="kn">import</span> <span class="n">E</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">CLASS</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span> <span class="c1"># class is a reserved word in Python</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;class&quot;</span><span class="p">:</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">)}</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">html</span> <span class="o">=</span> <span class="n">page</span> <span class="o">=</span> <span class="p">(</span>
<span class="gp">... </span>  <span class="n">E</span><span class="o">.</span><span class="n">html</span><span class="p">(</span>       <span class="c1"># create an Element called &quot;html&quot;</span>
<span class="gp">... </span>    <span class="n">E</span><span class="o">.</span><span class="n">head</span><span class="p">(</span>
<span class="gp">... </span>      <span class="n">E</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;This is a sample document&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="p">),</span>
<span class="gp">... </span>    <span class="n">E</span><span class="o">.</span><span class="n">body</span><span class="p">(</span>
<span class="gp">... </span>      <span class="n">E</span><span class="o">.</span><span class="n">h1</span><span class="p">(</span><span class="s2">&quot;Hello!&quot;</span><span class="p">,</span> <span class="n">CLASS</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)),</span>
<span class="gp">... </span>      <span class="n">E</span><span class="o">.</span><span class="n">p</span><span class="p">(</span><span class="s2">&quot;This is a paragraph with &quot;</span><span class="p">,</span> <span class="n">E</span><span class="o">.</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;bold&quot;</span><span class="p">),</span> <span class="s2">&quot; text in it!&quot;</span><span class="p">),</span>
<span class="gp">... </span>      <span class="n">E</span><span class="o">.</span><span class="n">p</span><span class="p">(</span><span class="s2">&quot;This is another paragraph, with a&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">      &quot;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">E</span><span class="o">.</span><span class="n">a</span><span class="p">(</span><span class="s2">&quot;link&quot;</span><span class="p">,</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;http://www.python.org&quot;</span><span class="p">),</span> <span class="s2">&quot;.&quot;</span><span class="p">),</span>
<span class="gp">... </span>      <span class="n">E</span><span class="o">.</span><span class="n">p</span><span class="p">(</span><span class="s2">&quot;Here are some reservered characters: &lt;spam&amp;egg&gt;.&quot;</span><span class="p">),</span>
<span class="gp">... </span>      <span class="n">etree</span><span class="o">.</span><span class="n">XML</span><span class="p">(</span><span class="s2">&quot;&lt;p&gt;And finally an embedded XHTML fragment.&lt;/p&gt;&quot;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">)</span>
<span class="gp">... </span>  <span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">&lt;html&gt;</span>
<span class="go">  &lt;head&gt;</span>
<span class="go">    &lt;title&gt;This is a sample document&lt;/title&gt;</span>
<span class="go">  &lt;/head&gt;</span>
<span class="go">  &lt;body&gt;</span>
<span class="go">    &lt;h1 class=&quot;title&quot;&gt;Hello!&lt;/h1&gt;</span>
<span class="go">    &lt;p&gt;This is a paragraph with &lt;b&gt;bold&lt;/b&gt; text in it!&lt;/p&gt;</span>
<span class="go">    &lt;p&gt;This is another paragraph, with a</span>
<span class="go">      &lt;a href=&quot;http://www.python.org&quot;&gt;link&lt;/a&gt;.&lt;/p&gt;</span>
<span class="go">    &lt;p&gt;Here are some reservered characters: &amp;lt;spam&amp;amp;egg&amp;gt;.&lt;/p&gt;</span>
<span class="go">    &lt;p&gt;And finally an embedded XHTML fragment.&lt;/p&gt;</span>
<span class="go">  &lt;/body&gt;</span>
<span class="go">&lt;/html&gt;</span>
</pre></div>
</div>
<p>Element creation based on attribute access makes it easy to build up a
simple vocabulary for an XML language:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lxml.builder</span> <span class="kn">import</span> <span class="n">ElementMaker</span> <span class="c1"># lxml only !</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="n">ElementMaker</span><span class="p">(</span><span class="n">namespace</span><span class="o">=</span><span class="s2">&quot;http://my.de/fault/namespace&quot;</span><span class="p">,</span>
<span class="gp">... </span>                 <span class="n">nsmap</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;p&#39;</span> <span class="p">:</span> <span class="s2">&quot;http://my.de/fault/namespace&quot;</span><span class="p">})</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">DOC</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">doc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TITLE</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">title</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SECTION</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">section</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PAR</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">par</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">my_doc</span> <span class="o">=</span> <span class="n">DOC</span><span class="p">(</span>
<span class="gp">... </span>  <span class="n">TITLE</span><span class="p">(</span><span class="s2">&quot;The dog and the hog&quot;</span><span class="p">),</span>
<span class="gp">... </span>  <span class="n">SECTION</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">TITLE</span><span class="p">(</span><span class="s2">&quot;The dog&quot;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">PAR</span><span class="p">(</span><span class="s2">&quot;Once upon a time, ...&quot;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">PAR</span><span class="p">(</span><span class="s2">&quot;And then ...&quot;</span><span class="p">)</span>
<span class="gp">... </span>  <span class="p">),</span>
<span class="gp">... </span>  <span class="n">SECTION</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">TITLE</span><span class="p">(</span><span class="s2">&quot;The hog&quot;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">PAR</span><span class="p">(</span><span class="s2">&quot;Sooner or later ...&quot;</span><span class="p">)</span>
<span class="gp">... </span>  <span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">my_doc</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">&lt;p:doc xmlns:p=&quot;http://my.de/fault/namespace&quot;&gt;</span>
<span class="go">  &lt;p:title&gt;The dog and the hog&lt;/p:title&gt;</span>
<span class="go">  &lt;p:section&gt;</span>
<span class="go">    &lt;p:title&gt;The dog&lt;/p:title&gt;</span>
<span class="go">    &lt;p:par&gt;Once upon a time, ...&lt;/p:par&gt;</span>
<span class="go">    &lt;p:par&gt;And then ...&lt;/p:par&gt;</span>
<span class="go">  &lt;/p:section&gt;</span>
<span class="go">  &lt;p:section&gt;</span>
<span class="go">    &lt;p:title&gt;The hog&lt;/p:title&gt;</span>
<span class="go">    &lt;p:par&gt;Sooner or later ...&lt;/p:par&gt;</span>
<span class="go">  &lt;/p:section&gt;</span>
<span class="go">&lt;/p:doc&gt;</span>
</pre></div>
</div>
<p>One such example is the module <code class="docutils literal"><span class="pre">lxml.html.builder</span></code>, which provides a
vocabulary for HTML.</p>
<p>When dealing with multiple namespaces, it is good practice to define
one ElementMaker for each namespace URI.  Again, note how the above
example predefines the tag builders in named constants.  That makes it
easy to put all tag declarations of a namespace into one Python module
and to import/use the tag name constants from there.  This avoids
pitfalls like typos or accidentally missing namespaces.</p>
</div>
<div class="section" id="elementpath">
<h2><a class="toc-backref" href="#id20">ElementPath</a><a class="headerlink" href="#elementpath" title="Permalink to this headline">Â¶</a></h2>
<p>The ElementTree library comes with a simple XPath-like path language
called <a class="reference external" href="http://effbot.org/zone/element-xpath.htm">ElementPath</a>.  The main difference is that you can use the
<code class="docutils literal"><span class="pre">{namespace}tag</span></code> notation in ElementPath expressions.  However,
advanced features like value comparison and functions are not
available.</p>
<p>In addition to a <a class="reference external" href="xpathxslt.html#xpath">full XPath implementation</a>, <code class="docutils literal"><span class="pre">lxml.etree</span></code> supports the
ElementPath language in the same way ElementTree does, even using
(almost) the same implementation.  The API provides four methods here
that you can find on Elements and ElementTrees:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">iterfind()</span></code> iterates over all Elements that match the path
expression</li>
<li><code class="docutils literal"><span class="pre">findall()</span></code> returns a list of matching Elements</li>
<li><code class="docutils literal"><span class="pre">find()</span></code> efficiently returns only the first match</li>
<li><code class="docutils literal"><span class="pre">findtext()</span></code> returns the <code class="docutils literal"><span class="pre">.text</span></code> content of the first match</li>
</ul>
<p>Here are some examples:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XML</span><span class="p">(</span><span class="s2">&quot;&lt;root&gt;&lt;a x=&#39;123&#39;&gt;aText&lt;b/&gt;&lt;c/&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Find a child of an Element:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">a</span>
</pre></div>
</div>
<p>Find an Element anywhere in the tree:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;.//b&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span> <span class="n">b</span><span class="o">.</span><span class="n">tag</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iterfind</span><span class="p">(</span><span class="s2">&quot;.//b&quot;</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[&#39;b&#39;, &#39;b&#39;]</span>
</pre></div>
</div>
<p>Find Elements with a certain attribute:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;.//a[@x]&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;.//a[@y]&quot;</span><span class="p">))</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>In lxml 3.4, there is a new helper to generate a structural ElementPath
expression for an Element:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">ElementTree</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getelementpath</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">a/b[1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getelementpath</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">a/c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getelementpath</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">a/b[2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">getelementpath</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">==</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As long as the tree is not modified, this path expression represents an
identifier for a given element that can be used to <code class="docutils literal"><span class="pre">find()</span></code> it in the same
tree later.  Compared to XPath, ElementPath expressions have the advantage
of being self-contained even for documents that use namespaces.</p>
<p>The <code class="docutils literal"><span class="pre">.iter()</span></code> method is a special case that only finds specific tags
in the tree by their name, not based on a path.  That means that the
following commands are equivalent in the success case:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;.//b&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">iterfind</span><span class="p">(</span><span class="s2">&quot;.//b&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">b</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal"><span class="pre">.find()</span></code> method simply returns None if no match is found,
whereas the other two examples would raise a <code class="docutils literal"><span class="pre">StopIteration</span></code> exception.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, lxml project.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  
    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'3.7.2',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>